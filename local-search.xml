<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/10/19/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>title: Linux<br>date: 2022-10-19 16:45:18<br>tags: Linux</p><h1 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h1><ol><li><p>bin：存放二进制执行文件</p></li><li><p>etc：存放系统配置文件</p></li><li><p>home：存放用户文件的根目录</p></li><li><p>lib：存放类库文件、内核模块</p></li><li><p>指令</p><ul><li><p>切换目录cd</p><ul><li><p>根目录/</p></li><li><p>上级..</p></li><li><p>路径</p></li></ul></li><li><p>展示当前目录中所有的内容ls</p><ul><li><p>-a 展示包括隐藏内容在内的所有内容</p></li><li><p>-l 展示不包括隐藏内容其他所有内容的详细信息</p></li></ul></li><li><p>创建文件夹mkdir</p><ul><li><p>可以同时创建多个，空格隔开</p></li><li><p>mkdir -p ff/kk 嵌套创建，创建ff文件夹，在ff文件夹里再创建一个kk文件夹</p></li></ul></li><li><p>删除文件夹rmdir</p><ul><li>直接使用rmdir删除的话文件夹必须为空，可以使用rm -rf命令不询问来删除不为空的文件夹</li><li>文件夹为空的话，同上创建文件夹，可以删除多个，可以删除嵌套（包括被嵌套的文件夹）</li></ul></li><li><p>创建文件touch</p><ul><li>touch a.txt</li></ul></li><li><p>删除文件rm</p><ul><li>直接rm有询问，不询问加-f</li><li>不能直接rm文件夹名字，可以使用-r递归删除来删除文件夹和里面的内容</li><li>rm -rf * 删除所有内容</li></ul></li><li><p>编辑vim和vi</p><ul><li>先输入小写i进入插入模式，再进行编辑</li><li>编辑完之后按Esc退出插入数据模式，在输入:wq!（小写）退出编辑器</li><li>i当前、I当前行首、a当前位置之后、A当前行尾、o下一行、O上一行</li><li>非插入数据模式下，dd快速删除一行数据，/s快速查找名字有s的文件（s可换）</li></ul></li><li><p>展示内容cat、more、less、tail</p><ul><li>cat展示所有内容</li><li>more可以分页，空格查看下一页，回车查看下一行</li><li>less也是分页，同上，方向键上下可以查看上下行</li><li>tail默认展示最后十行数据，加参数-5展示后5行</li></ul></li><li><p>移动mv</p><ul><li>可以移动多个文件</li><li>可以给文件改名 mv a.txt aa.txt</li></ul></li><li><p>复制cp</p><ul><li>文件名不能重复，后缀名要写上</li></ul></li><li><p>打包、压缩和解压tar</p><ul><li><p>打包：tar -cvf 名字.tar ./*</p><p>​    c 创建/生成，意思是生成一个包</p><p>​    v 展示整个打包的过程</p><p>​    f 指定包名，包名的后缀名必须是*.tar</p><p>​    ./*表示当前目录中所有内容打包</p><p>​    也可以针对某个文件或者文件夹打包</p></li><li><p>压缩：tar -zcvf 名字.tar ./*</p></li><li><p>解压：tar -xvf 真实存在的包名/压缩包名</p><p>​    tar -xvf *.tar -C /home/roott 把解压出来的内容放到指定目录中</p></li></ul></li><li><p>文件查找find</p><ul><li>find . 查看当前路径中所有文件和文件夹</li><li>find /aa -name “*.txt” 查看指定目录中，名字是txt结尾的文件</li><li>find /aa -name “* .txt” -o “*.mp3”，-o是或者的意思，有符合的就显示，没有就不显示</li><li>find /aa ! -name “*.txt” ，!是非的意思，表示不是.txt结尾的文件</li><li>find -type f -atime -7 表示查看7天内访问过的所有文件</li></ul></li><li><p>展示当前所在路径pwd</p></li><li><p>查看网络连通ping加网站</p></li><li><p>显示系统运行时间uptime</p></li><li><p>展示详细文件信息stat</p></li><li><p>友好显示信息（数据大小进行单位化展示）ll -h</p></li><li><p>下载文件wget加下载网址</p></li><li><p>重定向输出&gt;和&gt;&gt;（右边没有会默认创建）</p><ul><li>cat a.txt &gt; b.txt</li><li>ifconfig &gt; ifconfig.txt</li><li>一个&gt;表示覆盖原有内容</li><li>两个&gt;&gt;表示在原有内容基础上追加内容</li></ul></li><li><p>查找符合条件的字符串grep</p><ul><li><p>grep 查找内容 文件名，表示在这个文件中查找这个内容</p></li><li><p>可以在最后跟–color，表示把查找内容高亮显示</p></li></ul></li><li><p>管道，将一个命令的输出用作另一个命令的输入 |</p><ul><li><p>例如ls –help | more 表示分页查询帮助信息</p></li><li><p>ps -ef | grep java 查询名称中包含java的进程</p></li><li><p>ps -ef | grep 2251 查询2251端口号对应的进程</p></li></ul></li><li><p>命令执行控制逻辑与&amp;&amp;，前真后执行，有假后不执行</p></li><li><p>网络通讯命令netstat，查看网络端口</p><ul><li>netstat -an | grep 3306 查询3306端口占用情况</li></ul></li><li><p>搜索命令which、whereis、locate</p><ul><li><p>which查找给定命令的绝对路径</p></li><li><p>whereis查找命令的二进制程序、源代码文件以及man手册页等相关文件路径</p></li><li><p>locate使用前先用updatedb更新库，类似于find -name，比find -name快</p></li></ul></li><li><p>系统管理命令date、df、free、top、clear、ps、kill、who、hostname、uname</p><ul><li>date显示系统时间，-s可以自己设置</li><li>df查看系统磁盘设备，默认为KB，-h显示G，-m显示MB</li><li>free显示内存状态，-m显示MB</li><li>top显示管理执行中进程，类似于任务管理器</li><li>clear清屏</li><li>ps -ef 查看所有进程，配合管道和grep可以定位查找某一进程</li><li>kill杀进程，-9参数强制杀死</li><li>who显示目前登入系统用户信息</li><li>hostname查看主机名，使用vim /etc/sysconfig/network可以修改，需要重启虚拟机</li><li>uname显示系统信息，-a可以详细显示</li></ul></li><li><p>用户管理命令useradd、passwd、su、userdel</p><ul><li>useradd 添加用户，-d /home/xxx 指定home目录进行添加用户 -d </li><li>passwd设置密码，跟用户名可以为指定用户设置</li><li>su 切换用户</li><li>userdel删除，直接用不会删除home目录，-f可以删除已登录的，-r可以删除用户以及home目录</li></ul></li><li><p>组管理命令groupadd</p><ul><li>同useradd</li><li>useradd 名字 -g 组名 可以创建用户指定组</li><li>groupdel删除只能删除空组，有用户必须先删用户</li></ul></li><li><p>查看用户的UID和GID命令id</p><ul><li>直接id 用户名</li><li>查看系统文件<ul><li>/etc/passwd 用户文件</li><li>/etc/shadow 密码文件</li><li>/etc/group 组信息文件</li></ul></li></ul></li><li><p>修改权限命令chmod</p><ul><li>rwx 分别为421，通过chmod 数字 文件名 可以修改权限</li></ul></li><li><p>防火墙指令chkconfig</p><ul><li>永久关闭或打开 chkconfig iptables off/on</li><li>查看关闭所有端口 chkconfig iptables –list</li><li>临时关闭或打开 service iptables stop/start</li><li>重启 service iptables restart</li><li>查看防火墙状态 service iptables status</li><li>通过vi命令修改端口开放信息 vi /etc/sysconfig/iptables</li></ul></li><li><p>服务器通信指令ssh</p><ul><li>直接连接 ssh ip地址</li><li>指定用户名和端口连接 默认端口22：ssh 用户名@ip地址 -p 端口号</li><li>退出 logout</li><li>传输文件scp 文件路径 目标主机用户名@ip:/文件夹名/</li><li>拷贝文件夹 scp加参数-r</li></ul></li><li><p>补充</p><ul><li>在Linux系统中，不以文件后缀区分文件类型，而是以第一个字符标识文件类型，不管是文件后缀是<code>.c</code>还是<code>.txt</code>或是其他后缀，只有是以-开头的就是普通文件<ul><li>d：目录文件，简单来说就是文件夹，我们可以在该目录文件下新建文件</li><li>-：普通文件，分为文本文件、动静态库、可执行程序等</li><li>l：软链接（类似Windows的快捷方式）</li><li>b：块设备文件（例如硬盘、光驱等）</li><li>p：管道文件</li><li>c：字符设备文件（例如屏幕等串口设备）</li><li>s：套接口文件</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/09/15/Redis/"/>
    <url>/2022/09/15/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis："><a href="#Redis：" class="headerlink" title="Redis："></a>Redis：</h1><h4 id="一、Redis（Remote-Dictionary-Server）C语言开发的高性能键值对（key-value）的数据库"><a href="#一、Redis（Remote-Dictionary-Server）C语言开发的高性能键值对（key-value）的数据库" class="headerlink" title="一、Redis（Remote Dictionary Server）C语言开发的高性能键值对（key-value）的数据库"></a>一、Redis（Remote Dictionary Server）C语言开发的高性能键值对（key-value）的数据库</h4><p>​    <strong>NoSql</strong>：Not-Only Sql（泛指非关系型数据库），作为关系型数据库的补充。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本指令<br><span class="hljs-regexp">//</span>存<br>set key value<br><span class="hljs-regexp">//</span>取（不存在返回nil）<br>get key<br><span class="hljs-regexp">//</span>清屏<br>clear<br><span class="hljs-regexp">//</span>获取命令帮助<br>help 命令名称<br>help @组名<br><span class="hljs-regexp">//</span>退出<br>quit<br><span class="hljs-keyword">exit</span><br>&lt;ESC&gt;<br></code></pre></td></tr></table></figure><h4 id="二、Redis数据类型（string、hash、list、set、sorted-set）："><a href="#二、Redis数据类型（string、hash、list、set、sorted-set）：" class="headerlink" title="二、Redis数据类型（string、hash、list、set、sorted_set）："></a>二、Redis数据类型（string、hash、list、set、sorted_set）：</h4><p>​    <strong>指的是value部分数据的类型</strong></p><h3 id="1-string："><a href="#1-string：" class="headerlink" title="1.string："></a>1.<strong>string</strong>：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本操作<br>set get del<br><span class="hljs-regexp">//</span>多个数据<br>mset mget<br><span class="hljs-regexp">//</span>字符串长度<br>strlen<br><span class="hljs-regexp">//</span>追加信息（存在追加，不存在新建）<br>append<br></code></pre></td></tr></table></figure><p>​    <strong>单数据和多数据选择：redis数据操作是单线程的，多数据要及时切割</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>扩展操作（分库分表）<br><span class="hljs-regexp">//</span>增长指令，只有当value为数字时才能增长<br><span class="hljs-regexp">//</span>加<span class="hljs-number">1</span><br>incr key<br><span class="hljs-regexp">//</span>加固定的值（整数）<br>incrby key increment<br><span class="hljs-regexp">//</span>加固定的值（小数）<br>incrbyfloat key increment <br><br><span class="hljs-regexp">//</span>减少指令，有当value为数字时才能减少<br>decr key<br>decrby key increment<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>string在redis内部默认是字符串，当遇到增减类操作incr，decr时会转成<strong>数值型</strong>进行计算。</li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p>tips1：</p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></li><li>此方案适用于所有数据库，且支持数据库集群</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置数据具有指定的声明周期<br><span class="hljs-regexp">//</span>秒<br>setex key seconds value<br><span class="hljs-regexp">//</span>毫秒<br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><p>tips2：</p><ul><li>redis控制数据的声明周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li></ul><p><strong>string数据最大存储量为512MB</strong></p><p>tips3：</p><ul><li><p>数据库中热点数据key命名规范</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142355.png" alt="img"></p></li></ul><h3 id="2-hash："><a href="#2-hash：" class="headerlink" title="2.hash："></a>2.hash：</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142425.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本指令<br><span class="hljs-regexp">//</span>插入（如果已存在同名的field，会被覆盖）<br>hset key field value<br>hmset key field1 value1 field2 value2...<br><span class="hljs-regexp">//</span>插入（如果已存在同名的field，不会被覆盖）<br>hsetnx key field value<br><br><span class="hljs-regexp">//</span>取出<br>hget key field<br>hgetall key<br><br><span class="hljs-regexp">//</span>删除<br>hdel key field1 field2...<br><br><span class="hljs-regexp">//</span>获取field数量<br>hlen key<br><br><span class="hljs-regexp">//</span>查看是否存在<br>hexists key field<br><br><span class="hljs-regexp">//</span>获取哈希表中所有的字段名或字段值 <br>hkeys key<br>hvals key<br><br><span class="hljs-regexp">//</span>设置指定字段的数值数据增加指定范围的值 <br>hincrby key field increment <br>hdecrby key field increment<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>hash类型下的value只能存<strong>字符串</strong>，不能存其他类型的数据，不存在嵌套现象，如果未获取到，对应的值为nil。</li><li>每个hash可以存储<strong>2的32次方-1</strong>个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，<strong>更不可以将hash作为对象列表使用</strong></li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li></ul><h3 id="3-list："><a href="#3-list：" class="headerlink" title="3.list："></a>3.list：</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的<strong>顺序</strong>进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以<strong>体现进入顺序</strong></li><li>list类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现</li><li><strong>元素有序，且可重</strong></li></ul><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tcl">//基本指令<br>//添加修改数据,lpush为从左边添加，rpush为从右边添加<br>lpush key value1 value2 value3...<br>rpush key value1 value2 value3...<br><br>//右进左查<br>//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素<br>//lpush先进的元素放在最后,rpush先进的元素放在最前面<br><span class="hljs-keyword">lrange</span> key start end<br>//得到长度<br>llen key<br>//取出对应索引的元素<br><span class="hljs-keyword">lindex</span> key index<br><br>//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）<br>lpop key<br>rpop key<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拓展指令<br><span class="hljs-regexp">//</span>阻塞式数据获取<br><span class="hljs-regexp">//</span>规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除<br>blpop key1 key2... timeout<br>brpop key1 key2... timeout<br><br><span class="hljs-regexp">//</span>移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除<br>lrem key count value<br></code></pre></td></tr></table></figure><ul><li>redis可以用于具有操作先后顺序的数据控制</li><li>redis可以用于最新消息的展示以及消息的排队</li></ul><p><strong>注意事项：</strong></p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul><h3 id="4-set："><a href="#4-set：" class="headerlink" title="4.set："></a>4.set：</h3><p><strong>不重复并且无序</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211105183420194.png" alt="image-20211105183420194"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本指令<br><span class="hljs-regexp">//</span>添加元素<br>sadd key member1 member2...<br><br><span class="hljs-regexp">//</span>查看元素<br>smembers key<br><br><span class="hljs-regexp">//</span>移除元素<br>srem key member<br><br><span class="hljs-regexp">//</span>查看元素个数<br>scard key<br><br><span class="hljs-regexp">//</span>查看某个元素是否存在<br>sismember key member<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//拓展指令</span><br><span class="hljs-comment">//从set中任意选出count个元素</span><br>srandmember key count<br><br><span class="hljs-comment">//从set中任意选出count个元素并移除</span><br>spop key count<br><br><span class="hljs-comment">//求两个集合的交集、并集、差集</span><br><span class="hljs-function"><span class="hljs-title">sinter</span></span> key1 key2...<br><span class="hljs-function"><span class="hljs-title">sunion</span></span> key1 key2...<br><span class="hljs-function"><span class="hljs-title">sdiff</span></span> key1 key2...<br><br><span class="hljs-comment">//求两个set的交集、并集、差集，并放入另一个set中</span><br><span class="hljs-function"><span class="hljs-title">sinterstore</span></span> destination key1 key2...<br><span class="hljs-function"><span class="hljs-title">sunionstore</span></span> destination key1 key2...<br><span class="hljs-function"><span class="hljs-title">sdiffstore</span></span> destination key1 key2...<br><br><span class="hljs-comment">//求指定元素从原集合放入目标集合中</span><br>smove source destination key<br></code></pre></td></tr></table></figure><ul><li>redis可以用于随机推荐类信息的检索</li><li>redis可以用于关联检索</li><li>redis可以用于同类型数据快速去重</li><li>redis可以用于同类型不重复数据的合并操作</li><li>redis可以应用于基于黑白名单的服务控制</li></ul><h3 id="5-sorted-set"><a href="#5-sorted-set" class="headerlink" title="5.sorted_set:"></a>5.sorted_set:</h3><ul><li><strong>不重但有序（score）</strong></li><li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</li><li>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li></ul><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211105193413952.png" alt="image-20211105193413952"></p><p><strong>注意：score里面不要理解为存储数据，要理解为排序！！</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xquery">//基本指令<br>//插入元素, 需要指定score(用于排序)<br>zadd<span class="hljs-built_in"> key</span> score1 member1 score2 member2<br><br>//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来<br>zrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)<br>//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来<br>zrevrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)<br><br>//移除元素<br>zrem<span class="hljs-built_in"> key</span> member1 member2...<br><br>//按条件获取数据, 其中offset为索引开始位置<span class="hljs-built_in">，count</span>为获取的数目<br>zrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span> [withscore] [limit offset<span class="hljs-built_in"> count</span>]<br>zrevrangebyscore<span class="hljs-built_in"> key</span><span class="hljs-built_in"> max</span><span class="hljs-built_in"> min</span> [withscore] [limit offset<span class="hljs-built_in"> count</span>]<br><br>//按条件移除元素<br>zremrangebyrank<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span><br>zremrangebysocre<span class="hljs-built_in"> key</span><span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span><br>//按照从大到小的顺序移<span class="hljs-built_in">除count</span>个值<br>zpopmax<span class="hljs-built_in"> key</span> <span class="hljs-built_in">[count</span>]<br>//按照从小到大的顺序移<span class="hljs-built_in">除count</span>个值<br>zpopmin<span class="hljs-built_in"> key</span> <span class="hljs-built_in">[count</span>]<br><br>//获得元素个数<br>zcard<span class="hljs-built_in"> key</span><br><br>//获得元素在范围内的个数<br>zcount<span class="hljs-built_in"> min</span><span class="hljs-built_in"> max</span><br><br>//求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目<br>zinterstore destination numkeys key1 key2...<br>zunionstore destination numkeys key1 key2...<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong></li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拓展指令<br><span class="hljs-regexp">//</span>查看某个元素的索引(排名)<br>zrank key member<br>zrevrank key member<br><br><span class="hljs-regexp">//</span>查看某个元素索引的值<br>zscore key member<br><span class="hljs-regexp">//</span>增加某个元素索引的值<br>zincrby key increment member<br><br><span class="hljs-regexp">//</span>获取系统当前时间<br>time<br></code></pre></td></tr></table></figure><ul><li>redis可以用于计数器组合排序功能对应的排名</li><li>redis可以用于定时任务执行顺序管理或任务过期管理（分段）</li><li>redis可以用于即时任务/消息队列的执行管理</li><li>redis可以用于按次结算的服务控制</li></ul><p><strong>注意事项：</strong></p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li></ul><h4 id="三、key的通用操作"><a href="#三、key的通用操作" class="headerlink" title="三、key的通用操作"></a>三、key的通用操作</h4><p>key特征：key是一个字符串，通过key获取redis中保存的数据。</p><p><strong>key的操作：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本指令<br><span class="hljs-regexp">//</span>查看key是否存在<br>exists key<br><br><span class="hljs-regexp">//</span>删除key<br>del key<br><br><span class="hljs-regexp">//</span>查看key的类型<br>type key<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//拓展操作（时效性操作）</span><br><span class="hljs-comment">//设置生命周期</span><br>expire <span class="hljs-built_in">key</span> seconds<br>pexpire <span class="hljs-built_in">key</span> milliseconds<br><br><span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br>ttl <span class="hljs-built_in">key</span><br>pttl <span class="hljs-built_in">key</span><br><br><span class="hljs-comment">//将有时限的数据设置为永久有效</span><br>persist <span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拓展操作（查询操作）<br><span class="hljs-regexp">//</span>根据key查询符合条件的数据<br>keys pattern<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211106145341907.png" alt="image-20211106145341907"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拓展操作（改名）<br><span class="hljs-regexp">//</span>重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx<br>rename key newKey<br>renamenx key newKey<br><br><span class="hljs-regexp">//</span>排序<br>sort<br><br><span class="hljs-regexp">//</span>查看所有关于key的操作, 可以使用Tab快速切换<br>help @generic<br></code></pre></td></tr></table></figure><h4 id="四、数据库通用指令"><a href="#四、数据库通用指令" class="headerlink" title="四、数据库通用指令"></a>四、数据库通用指令</h4><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>避免key重复问题</p><ul><li>Redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>基本指令<br><span class="hljs-regexp">//</span>切换数据库 <span class="hljs-number">0</span>~<span class="hljs-number">15</span><br>select index<br><br><span class="hljs-regexp">//</span>其他操作<br>quit<br>ping<br>echo massage<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>拓展操作<br><span class="hljs-regexp">//</span>移动数据, 必须保证目的数据库中没有该数据<br>mov key db<br><br><span class="hljs-regexp">//</span>查看该库中数据总量<br>dbsize<br></code></pre></td></tr></table></figure><h4 id="五、Jedis"><a href="#五、Jedis" class="headerlink" title="五、Jedis"></a>五、Jedis</h4><p><strong>先导入maven</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">2.9</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><ul><li>连接Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span><br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(String host, <span class="hljs-type">int</span> port)Copy<br></code></pre></td></tr></table></figure><ul><li>操作Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span><br>jedis.set(String key, String value);Copy<br></code></pre></td></tr></table></figure><ul><li>断开连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">redis.host=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>redis.port=<span class="hljs-number">6379</span><br>redis.maxTotal=<span class="hljs-number">30</span><br>redis.maxIdle=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisUtil</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> port;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> maxTotal;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> maxIdle;<br><br><span class="hljs-comment">//使用静态代码块，只加载一次</span><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">//读取配置文件</span><br><span class="hljs-type">ResourceBundle</span> <span class="hljs-variable">resourceBundle</span> <span class="hljs-operator">=</span> ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br><span class="hljs-comment">//获取配置文件中的数据</span><br>host = resourceBundle.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br><span class="hljs-comment">//读取最大连接数</span><br>maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br><span class="hljs-comment">//读取最大活跃数</span><br>maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br><span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>jedisPoolConfig.setMaxTotal(maxTotal);<br>jedisPoolConfig.setMaxIdle(maxIdle);<br><span class="hljs-comment">//获取连接池</span><br><span class="hljs-type">JedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, host, port);<br>jedis = jedisPool.getResource();<br>&#125;<br><br><span class="hljs-keyword">public</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> jedis;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="六、redis进阶（Linux环境下）"><a href="#六、redis进阶（Linux环境下）" class="headerlink" title="六、redis进阶（Linux环境下）"></a>六、redis进阶（Linux环境下）</h4><p><strong>安装</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116082629402.png" alt="image-20211116082629402"></p><p><strong>服务启动</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116083552409.png" alt="image-20211116083552409"></p><p><strong>基本配置</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116084353041.png" alt="image-20211116084353041"></p><h4 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h4><h6 id="以下为RDB启动方式"><a href="#以下为RDB启动方式" class="headerlink" title="以下为RDB启动方式"></a><em>以下为RDB启动方式</em></h6><p><strong>概述</strong></p><ul><li>利用永久性存储介质将数据进行保存，在特定时间将保存的数据进行恢复的工作机制成为持久化</li></ul><p><strong>持久化保存什么东西？</strong></p><ul><li>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据    ——&gt;    数据（快照）RDB</li><li>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程    ——&gt;    过程（日志）AOF</li></ul><p><strong>命令</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>作用：手动保存一次命令<br><span class="hljs-regexp">//</span>执行后会生成一个dump.rdb文件保存快照信息<br>save<br></code></pre></td></tr></table></figure><p><strong>save相关配置</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116090127674.png" alt="image-20211116090127674"></p><p><strong>save指令原理</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142541.png" alt="img"></p><p><strong>注意：save指令的执行会阻塞当前redis服务器，直到当前的RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用！！！</strong></p><p><strong>解决方案：bgsave</strong></p><p><strong>命令</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>作用：手动启动后台保存操作，但不是立即执行<br>bgsave<br></code></pre></td></tr></table></figure><p><strong>bgsave工作原理</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116091317270.png" alt="image-20211116091317270"></p><p><strong>注意：bgsave命令是针对save的阻塞问题做的优化。Redis内部所涉及的RDB操作都采用bgsave的方式，save命令可以放弃使用。</strong></p><p><strong>bgsave相关配置</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116091456440.png" alt="image-20211116091456440"></p><p><strong>RDB启动方式 ——save配置</strong></p><ul><li><p>配置</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p></li><li><p>参数</p><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置</p></li></ul><p><strong>RDB启动方式 ——save配置原理</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142617.png" alt="img"></p><p><strong>注意</strong>：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系</li><li>save配置启动后执行的是<strong>bgsave操作</strong></li></ul><p><strong>RDB启动方式对比</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142629.png" alt="img"></p><p><strong>RDB特殊启动方式</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116092555320.png" alt="image-20211116092555320"></p><p><strong>RDB优缺点</strong></p><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li></ul></li></ul><p><em><strong>以下为AOF启动方式</strong></em></p><p><strong>AOF概念</strong></p><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li></ul><p><strong>AOF写数据过程</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png" alt="img"></p><p><strong>AOF写数据三种策略(appendfsync)</strong></p><ul><li>always（<strong>每次</strong>）<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec（<strong>每秒</strong>）<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置</li><li>在系统突然宕机的情况下丢失1秒内的数据</li></ul></li><li>no（<strong>系统控制</strong>）<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li></ul></li></ul><p><strong>AOF功能开启</strong></p><ul><li><p>配置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//作用：是否开启AOF持久化功能，默认为不开启状态</span><br>appendonly <span class="hljs-keyword">yes</span>|<span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//作用：AOF写数据策略</span><br>appendfsync always<span class="hljs-string">|everysec|no</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>AOF重写</strong></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件</li><li>忽略<strong>无效指令</strong>重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动重写</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span><br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-min-size size <br><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li></ul><p><strong>工作原理</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142657.png" alt="img"></p><p><strong>AOF自动重写方式</strong></p><ul><li><p>自动重写触发条件设置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//触发重写的最小大小</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-size size <br><span class="hljs-comment">//触发重写须达到的最小百分比</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percent<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>当前.aof的文件大小<br>aof_current_size <br><span class="hljs-regexp">//</span>基础文件大小<br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png" alt="img"></a></p></li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142734.png" alt="img"></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142755.png" alt="img"></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142814.png" alt="img"></p><p><strong>RDB VS AOF</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142837.png" alt="img"></p><p><strong>RDB和AOF选择之惑</strong></p><ul><li><p>对数据非常敏感，建议使用默认的AOF</p><p>持久化方案</p><ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li></ul></li><li><p>数据呈现阶段有效性，建议使用RDB持久化方案</p><ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li><p>综合比对</p><ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li><li><strong>灾难恢复选用RDB</strong></li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h4 id="七、Redis事务"><a href="#七、Redis事务" class="headerlink" title="七、Redis事务"></a>七、Redis事务</h4><p><strong>概念</strong></p><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><p><strong>事务的基本操作：</strong></p><p><strong>开启事务</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>作用：作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中<br>multi<br></code></pre></td></tr></table></figure><p><strong>取消事务</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>作用：终止当前事务的定义，发生在multi之后，exec之前<br>discard<br></code></pre></td></tr></table></figure><p><strong>执行事务</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用。<br>exec<br></code></pre></td></tr></table></figure><p><strong>注意：加入事务的命令暂存在任务队列中，并没有立即执行，只有执行了exec命令之后才会执行</strong></p><p><strong>事务操作的注意事项：</strong></p><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误<ul><li>指命令书写格式有误 例如执行了一条不存在的指令</li></ul></li><li>处理结果<ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p><ul><li>运行错误<ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</li></ul></li><li>处理结果<ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行</li></ul></li></ul><p><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</p><p><strong>手动事务回滚</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116104132591.png" alt="image-20211116104132591"></p><p><strong>基于特定条件事务的执行</strong></p><p><strong>锁：</strong></p><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">watch</span></span> key1, key2....<br></code></pre></td></tr></table></figure></li><li><p>取消对<strong>所有</strong>key的监视</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>分布式锁：</strong></p><ul><li><p>使用 setnx 设置一个公共锁</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>上锁<br>setnx lock-key value<br><span class="hljs-regexp">//</span>释放锁<br>del lock-key<br></code></pre></td></tr></table></figure><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁</li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p><p><strong>分布式锁加强</strong></p><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">expire <span class="hljs-keyword">lock</span>-key seconds<br>pexpire <span class="hljs-keyword">lock</span>-key milliseconds<br></code></pre></td></tr></table></figure></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul><h4 id="八、删除策略"><a href="#八、删除策略" class="headerlink" title="八、删除策略"></a>八、删除策略</h4><p><strong>Redis的数据特征</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211116105912918.png" alt="image-20211116105912918"></p><p><strong>Redis的删除策略</strong></p><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p><strong>时效性数据的存储结构</strong></p><ul><li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142921.png" alt="img"></p><p><strong>数据删除策略的目标</strong></p><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><p><strong>定时删除</strong></p><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li><li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li></ul><p><strong>惰性删除</strong></p><ul><li><p>数据到达过期时间，不做处理。等下次访问该数据时</p><ul><li><p>如果未过期，返回数据</p></li><li><p>发现已过期，删除，返回不存在</p></li></ul></li><li><p>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</p></li><li><p>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</p></li><li><p>总结：用存储空间换取处理器性能 （拿空间换时间）</p></li></ul><p><strong>定期删除</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142941.png" alt="img"></p><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li></ul><p><strong>删除策略的一个对比：</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211117095150683.png" alt="image-20211117095150683"></p><p><strong>逐出算法</strong></p><p>***        当新数据进入redis，但是内存不足时***</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()<strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为</strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。OOM</li></ul><p><strong>影响数据逐出的相关配置</strong></p><ul><li><p>最大可使用内存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span><br></code></pre></td></tr></table></figure><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span><br></code></pre></td></tr></table></figure><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p>删除策略</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span><br></code></pre></td></tr></table></figure><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p></li></ul><p><strong>影响数据逐出的相关配置</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142953.png" alt="img"></p><p><strong>LRU</strong>：最长时间没被使用的数据</p><p><strong>LFU</strong>：一段时间内使用次数最少的数据</p><p><strong>数据逐出策略配置依据</strong></p><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143004.png" alt="img"></p><p><strong>redis.conf配置文件</strong></p><p><strong>服务器基础配置：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置服务器以守护进程的方式进行<br>deamonize yes|no<br><span class="hljs-regexp">//</span>绑定主机地址<br>bind <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-regexp">//</span>设置服务器端口号<br>port <span class="hljs-number">6379</span><br><span class="hljs-regexp">//</span>设置数据库数量<br>databases <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>日志配置：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//设置服务器以指定日志记录级别（默认为<span class="hljs-keyword">verbose</span>）<br>loglevel <span class="hljs-keyword">debug</span>|<span class="hljs-keyword">verbose</span>|<span class="hljs-keyword">notice</span>|<span class="hljs-built_in">warning</span><br>//日志记录文件名<br>logfile 端口号.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>日志级别开发设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志的IO频度。</p><p><strong>客户端配置：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置同一时间最大客户端连接数量，默认无限制。当客户端连接达到上限，Redis会关闭新的连接。<br>maxclients <span class="hljs-number">0</span><br><span class="hljs-regexp">//</span>客户端闲置等待最大时长，达到最大值之后关闭连接。如果需要关闭该功能，设置为<span class="hljs-number">0</span>。<br>timeout <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211117223650553.png" alt="image-20211117223650553"></p><h4 id="九、高级数据类型"><a href="#九、高级数据类型" class="headerlink" title="九、高级数据类型"></a>九、高级数据类型</h4><p><strong>Bitmaps</strong></p><p><strong>基础操作</strong></p><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setbit key <span class="hljs-built_in">offset</span> value<br></code></pre></td></tr></table></figure></li></ul><p><strong>扩展操作</strong></p><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key1<span class="hljs-meta"> [key2...]</span><br></code></pre></td></tr></table></figure><ul><li>and：交</li><li>or：并</li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]<br></code></pre></td></tr></table></figure></li></ul><p><strong>HyperLogLog</strong></p><p><strong>基数</strong></p><ul><li>基数是数据集<strong>去重后元素个数</strong></li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143020.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143020.png" alt="img"></a></p><p><strong>基本操作</strong></p><ul><li><p>添加数据</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfadd</span></span> key element1, element2...Copy<br></code></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfcount</span></span> key1 key2....Copy<br></code></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pfmerge destkey sourcekey <span class="hljs-selector-attr">[sourcekey...]</span>Copy<br></code></pre></td></tr></table></figure></li></ul><p><strong>相关说明</strong></p><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li></ul><p><strong>GEO</strong></p><p><strong>基本操作</strong></p><ul><li><p>添加坐标点</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">geoadd key longitude latitude member <span class="hljs-comment">[longitude latitude member ...]</span> <br>georadius key longitude latitude radius m|km|ft|mi <span class="hljs-comment">[withcoord]</span> <span class="hljs-comment">[withdist]</span> <span class="hljs-comment">[withhash]</span> <span class="hljs-comment">[count count]</span><br></code></pre></td></tr></table></figure></li><li><p>获取坐标点</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...] <br>georadiusbymember <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> <span class="hljs-built_in">radius</span> m|km|ft|mi [withcoord] [withdist] [withhash] [count count]<br></code></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] <br>geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br></code></pre></td></tr></table></figure></li></ul><h4 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h4><p><strong>简介</strong></p><p><strong>多台服务器连接方案</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143033.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143033.png" alt="img"></a></p><ul><li>提供数据方：master<ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中</li></ul></li></ul><p><strong>主从复制</strong></p><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中</p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p><p>职责：</p><ul><li>master:<ul><li>写数据</li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave</li><li>读数据（可忽略）</li></ul></li><li>slave:<ul><li>读数据</li><li>写数据（<strong>禁止</strong>）</li></ul></li></ul><p><strong>作用</strong></p><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><p><strong>工作流程</strong></p><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a><strong>总述</strong></h4><ul><li>主从复制过程大体可以分为3个阶段<ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143046.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143046.png" alt="img"></a></p><h4 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h4><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143102.png" alt="img"></a></p></li></ul><p>**主从连接（slave连接master） **</p><ul><li><p>方式一：客户端发送命令</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式二：启动服务器参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方式三：服务器配置 （常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110845.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110845.png" alt="img"></a></p></li></ul><p><strong>主从断开连接</strong></p><ul><li><p><strong>客户端</strong>发送命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure><ul><li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据</li></ul></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>master配置文件设置密码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">set</span> requirepass &lt;password&gt; <span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">get</span> requirepass<br></code></pre></td></tr></table></figure></li><li><p>slave客户端发送命令设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave配置文件设置密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>slave启动服务器设置密码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143117.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143117.png" alt="img"></a></p><ul><li><p>全量复制</p><ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li><p>部分复制</p><p>（增量复制）</p><ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行</li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repl</span>-backlog-size <span class="hljs-number">1</span>mbCopy<br></code></pre></td></tr></table></figure><ol><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">slave</span>-serve-stale-<span class="hljs-class"><span class="hljs-keyword">data</span> yes|noCopy</span><br></code></pre></td></tr></table></figure><ol><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li></ol><h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul><li><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong></p></li><li><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p></li><li><p>主从复制过程大体可以分为3个阶段</p><ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul></li></ul><h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul><li><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连</li><li>短时间网络中断</li><li>长时间网络中断</li></ul></li><li><p>部分复制的<strong>三个核心要素</strong></p><ul><li>服务器的运行 id（run id）</li><li>主服务器的复制积压缓冲区</li><li>主从服务器的复制偏移量</li></ul></li></ul><h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如- -<ul><li>fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li></ul></li><li>作用：运行id被用于在服务器间进行传输，识别身份<ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li></ul></li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid</li></ul><h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul><li>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143134.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143134.png" alt="img"></a></p><h5 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h5><ul><li><p>组成</p><ul><li>偏移量</li><li>字节值</li></ul></li><li><p>工作原理</p><ul><li>通过offset区分不同的slave当前数据传播的差异</li><li>master记录<strong>已发送</strong>的信息对应的offset</li><li>slave记录<strong>已接收</strong>的信息对应的offset</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143149.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143149.png" alt="img"></a></p></li></ul><h5 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h5><ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类：<ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li><li>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul><h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143228.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143228.png" alt="img"></a></p><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul><li>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li>指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span>Copy<br></code></pre></td></tr></table></figure><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143241.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143241.png" alt="img"></a></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143304.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143304.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143317.png" alt="img"></a></p><h4 id="频繁的网络中断"><a href="#频繁的网络中断" class="headerlink" title="频繁的网络中断"></a>频繁的网络中断</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143327.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143327.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200821110907.png" alt="img"></a></p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143352.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143352.png" alt="img"></a></p><h4 id="十一、哨兵"><a href="#十一、哨兵" class="headerlink" title="十一、哨兵"></a>十一、哨兵</h4><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143401.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143401.png" alt="img"></a></p><h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>监控<ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li></ul></li><li>自动故障转移<ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul></li></ul><p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong></p><h3 id="3、配置哨兵"><a href="#3、配置哨兵" class="headerlink" title="3、配置哨兵"></a>3、配置哨兵</h3><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵（配置相同，端口不同）</p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">redis-sentinel sentinel端口号 <span class="hljs-string">.confCopy</span><br></code></pre></td></tr></table></figure></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143413.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143413.png" alt="img"></a></p><h3 id="4、工作原理"><a href="#4、工作原理" class="headerlink" title="4、工作原理"></a>4、工作原理</h3><h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><ul><li>用于同步各个节点的状态信息<ul><li>获取各个sentinel的状态（是否在线）</li></ul></li><li>获取master的状态<ul><li>master属性<ul><li>runid</li><li>role：master</li><li>各个slave的详细信息</li></ul></li></ul></li><li>获取所有slave的状态（根据master中的slave信息）<ul><li>slave属性<ul><li>runid</li><li>role：slave</li><li>master_host、master_port</li><li>offset</li><li>…</li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143539.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143539.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143602.png" alt="img"></a></p><h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143614.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143614.png" alt="img"></a></p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143633.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143633.png" alt="img"></a></p><h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143649.png" alt="img"></a></p><h5 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h5><ul><li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul><li>服务器列表中挑选备选master</li><li>在线的</li><li>响应慢的</li><li>与原master断开时间久的</li><li>优先原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li><li>发送指令（ sentinel ）<ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li></ul></li></ul><h4 id="十二、集群"><a href="#十二、集群" class="headerlink" title="十二、集群"></a>十二、集群</h4><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><ul><li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果</li></ul><h4 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h4><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong></li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong></li></ul><h3 id="2、Redis集群结构设计"><a href="#2、Redis集群结构设计" class="headerlink" title="2、Redis集群结构设计"></a>2、Redis集群结构设计</h3><h4 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h4><ul><li>通过算法设计，计算出key应该保存的位置</li><li>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143701.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143701.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143712.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143712.png" alt="img"></a></p><ul><li>增强可扩展性 ——槽</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143720.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143720.png" alt="img"></a></p><h4 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h4><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143733.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143733.png" alt="img"></a></p><p><strong>配置文件信息：</strong></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211119201030883.png" alt="image-20211119201030883"></p><p><img src="C:\Users\lyzdh\AppData\Roaming\Typora\typora-user-images\image-20211119201048941.png" alt="image-20211119201048941"></p><h4 id="十三、企业级解决方案"><a href="#十三、企业级解决方案" class="headerlink" title="十三、企业级解决方案"></a>十三、企业级解决方案</h4><h3 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h3><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>前置准备工作：<ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合</li></ul></li><li>准备工作：<ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul></li><li>实施：<ul><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h3 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol><h4 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>短时间范围内</li><li>大量key集中过期</li></ul><h4 id="解决方案（道）"><a href="#解决方案（道）" class="headerlink" title="解决方案（道）"></a>解决方案（道）</h4><ol><li>更多的页面静态化处理</li><li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制 监控redis服务器性能指标<ul><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol><p>解决方案（术）</p><ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量</li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁 <strong>慎用！</strong></li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143749.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143749.png" alt="img"></a></p><h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中</li><li>数据库连接量<strong>瞬间激增</strong></li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong></li></ol><h4 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>Redis中<strong>某个key过期，该key访问量巨大</strong></li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ol><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>单个key高热数据</li><li>key过期</li></ul><h4 id="解决方案（术）"><a href="#解决方案（术）" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h4><ol><li><p>预先设定</p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong></p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整</p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li></ul></li><li><p>后台刷新数据</p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li></ul></li><li><p>二级缓存</p><ul><li>设置不同的失效时间，保障不会被同时淘汰就行</li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong></p></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><h3 id="4、缓存穿透"><a href="#4、缓存穿透" class="headerlink" title="4、缓存穿透"></a>4、缓存穿透</h3><h4 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h4><p>我们的数据库中的主键都是从0开始的，即使我们将数据库中的所有数据都放到了缓存中。当有人用id=-1来发生<strong>恶意请求</strong>时，<strong>因为redis中没有这个数据，就会直接访问数据库，这就称谓缓存穿透</strong></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>在程序中进行数据的合法性检验，如果不合法直接返回</li><li>使用<a href="https://www.bilibili.com/video/BV19i4y1u7rV?from=search&seid=8200619784088161214"><strong>布隆过滤器</strong></a></li></ul><h4 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h4><p>想要尽量避免缓存穿透，一个办法就是对数据进行<strong>预校验</strong>，在对Redis和数据库进行操作前，<strong>先检查数据是否存在，如果不存在就直接返回。</strong>如果我们想要查询一个元素是否存在，要保证查询效率，可以选择HashSet，但是如果有10亿个数据，都用HashSet进行存储，<strong>内存肯定是无法容纳的</strong>。这时就需要布隆过滤器了</p><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（bit数组）和一系列随机映射函数（hash）。布隆过滤器可以用于检索一个元素是否在一个集合中</p><p>因为是基于<strong>位数组和hash函数</strong>的，所以它的<strong>优点</strong>是<strong>空间效率和查询</strong>时间都远远超过一般的算法。但<strong>缺点</strong>也很明显，那就是有一定的误识别率和删除困难。但是可以通过增加位数组的大小和增加hash函数个数来<strong>降低</strong>误识别率（<strong>只能降低，没法避免</strong>）</p><p><strong>放入过程</strong></p><p>布隆过滤器初始化后，位数组中的值都为0。当一个变量将要放入布隆过滤器时，会通过多个hash函数映射到位数组的各个位上，然后<strong>将对应位置为1</strong></p><p><strong>查询过程</strong></p><p>查询依然是通过多个hash函数映射到位数组的各个位上，如果各个位都为1，说明该元素<strong>可能存在，注意是可能存在！！</strong>。但是如果通过映射后，位数组对应位上<strong>不为1，那么该元素肯定不存在</strong></p><p><strong>放入过程图解</strong></p><p>比如我们的布隆过滤器位一个<strong>8位的位数组</strong>，并且有<strong>3个hash函数</strong>对元素进行计算，映射到数组中的各个位上</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191457.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191457.png" alt="img"></a></p><p>我们将字符串”Nyima”放入布隆过滤器中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191637.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191637.png" alt="img"></a></p><p>接下来将字符串”Cpower”放入布隆过滤器中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png" alt="img"></a></p><p><strong>查询过程图解</strong></p><p>比如我们要查询字符串”Cpower”是否存在，通过3个hash函数映射到了位数组的三个位置上， 三个位置都为1，那么该<strong>字符串可能存在</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204191725.png" alt="img"></a></p><p>比如我们要查询字符串”SWPU”是否存在，通过3个hash函数映射到了位数组的三个位置，发现有一个位置不为1，那么该<strong>字符串肯定不存在</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192628.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192628.png" alt="img"></a></p><p>比如我们要查询字符串”Hulu”是否存在，通过3个hash函数映射到了位数组的三个位置，发现所有位置都为1，但是我们前面并没有将字符串”Hulu”放入布隆过滤器中，所以这里<strong>发生了误判</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201204192741.png" alt="img"></a></p><p><strong>增加位数组的大小和hash函数个数可以降低误判率，但是无法避免误判</strong></p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
